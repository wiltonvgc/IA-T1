{
    "collab_server" : "",
    "contents" : "buscaEmLargura <- function(inicial, objetivo){\n  \n  abertos <- list(inicial)\n  fechados <- list()\n\n  while(length(abertos) != 0){\n    atual <- abertos[[1]]\n    abertos <- abertos[-1]\n    if(atual == objetivo){\n      return(recuperaCaminho(atual))\n    }else {\n      filhos <- geraFilhos(atual)\n      fechados <- c(fechados, atual)\n      filhos <- removeRepetidos(filhos, c(abertos, fechados))\n      abertos <- c(abertos, filhos) ## filhos têm prioridade menor! \n    }\n  }\n  return(\"Busca falhou! :'-(\")\n}\n\nbuscaEmProfundidade <- function(inicial, objetivo){\n  \n  abertos <- list(inicial)\n  fechados <- list()\n  \n  while(length(abertos) != 0){\n    atual <- abertos[[1]]\n    abertos <- abertos[-1]\n    if(atual == objetivo){\n      return(recuperaCaminho(atual))\n    }else {\n      filhos <- geraFilhos(atual)\n      fechados <- c(fechados, atual)\n      filhos <- removeRepetidos(filhos, c(abertos, fechados))\n      abertos <- c(filhos, abertos) ## filhos têm prioridade maior!\n    }\n  }\n  return(\"Busca falhou! :'-(\")\n}\n\nbuscaCustoUniforme <- function(inicial, objetivo){\n  \n  abertos <- list(inicial)\n  fechados <- list()\n  \n  while(length(abertos) != 0){\n    atual <- abertos[[1]]\n    abertos <- abertos[-1]\n    if(atual == objetivo){\n      return(recuperaCaminho(atual))\n    }else {\n      filhos <- geraFilhos(atual)\n      fechados <- c(fechados, atual)\n      filhosNovos <- removeRepetidos(filhos, c(abertos, fechados)) \n      ## se gera filhos que aparecem em abertos, atualiza o valor de custo\n      ## abertos devem estar ordenados por menor custo\n      abertos <- ordenaPorCusto(c(atualizaAbertos(abertos, filhos),filhosNovos))\n    }\n  }\n  return(\"Busca falhou! :'-(\")\n}\n\nrecuperaCaminho <- function(atual){\n  \n  caminho <- list()\n  \n  while(!is.null(atual)){\n    caminho <- c(caminho, atual)\n    atual <- atual$pai\n  }\n  \n  return(rev(caminho))\n}\n\nremoveRepetidos <- function(filhos, gerados){\n  \n  ## pega descrições dos estados já gerados\n  gDesc <- lapply(gerados, function(gerado) gerado$desc)\n  \n  ## verifica se filhos não aparece em estados gerados\n  fNovos <- sapply(filhos, function(filho) !is.element(list(filho$desc), gDesc))\n  \n  filhos <- filhos[fNovos]\n  \n  return(filhos)\n}\n\natualizaAbertos <- function(abertos, filhos){\n  \n  ## pega descrições dos estados na lista de abertos\n  aDesc <- lapply(abertos, function(aberto) aberto$desc)\n  \n  ## verifica se filhos aparece em estados da lista de abertos\n  fEmAbertos <- sapply(filhos, function(filho) is.element(list(filho$desc), aDesc))\n  \n  if(any(fEmAbertos)){ ## se existe ao menos um filho que já aparece na lista de abertos\n    \n    ## recupera apenas os filhos que aparecem na lista de abertos\n    filhosAbertos <- filhos[fEmAbertos]\n    \n    fADesc <- lapply(filhosAbertos, function(filhoAberto) filhoAberto$desc)\n    \n    selecionaAbertos <- sapply(abertos, function(aberto) is.element(list(aberto$desc),fADesc))\n    \n    atualizaAbertos <- abertos[selecionaAbertos]\n    \n    abertos <- abertos[!selecionaAbertos]\n    \n    atualizados <- list()\n    \n    for(filho in filhosAbertos){\n      for(atualiza in atualizaAbertos)\n        if((filho == atualiza) &&\n           (filho$g < atualiza$g)){\n          atualizados <- c(atualizados, list(filho))\n        }else{\n          atualizados <- c(atualizados, list(atualiza))\n        }\n        break\n    }\n    \n    abertos <- c(atualizados, abertos)\n  }\n  \n  \n  return(abertos)\n}\n\nordenaPorCusto <- function(abertos){\n  \n  aCusto <- t(as.data.frame(lapply(abertos, function(aberto) aberto$g)))\n  \n  rownames(aCusto) <- NULL\n  \n  ordemCusto <- order(aCusto)\n\n  abertos <- lapply(ordemCusto, function(ordIndice) abertos[[ordIndice]])\n  \n  return(abertos)\n}",
    "created" : 1482765641278.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1334949169",
    "id" : "A8511154",
    "lastKnownWriteTime" : 1482709382,
    "last_content_update" : 1482709382,
    "path" : "~/Documents/AI/T1/AspiradorDePo/buscaDesinformada.R",
    "project_path" : "buscaDesinformada.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}