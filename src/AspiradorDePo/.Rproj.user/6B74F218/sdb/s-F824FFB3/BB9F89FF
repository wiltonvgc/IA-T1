{
    "collab_server" : "",
    "contents" : "source(\"Estado.R\")\n\n## Classe e métodos para o problema do Aspirador de Po => 2 x 2\nAspiradorDePo <- function(desc = NULL, pai = NULL){\n  \n  e <- environment()\n  \n  assign(\"desc\", desc, envir = e)\n  assign(\"pai\", pai, envir = e)\n  assign(\"g\", 0, envir = e)\n  assign(\"h\", Inf, envir = e)\n  assign(\"f\", Inf, envir = e)\n  \n  class(e) <- c(\"AspiradorDePo\", \"Estado\")\n  \n  return(e)\n}\n\n## Sobrecarregando o operador \"==\" para comparação entre estados\nOps.AspiradorDePo = function(obj1,obj2){\n  if(.Generic == \"==\"){\n    return(all(obj1$desc[1:4] == obj2$desc[1:4]))\n  }\n}\n\n## Sobrecarga da função genérica \"print\" do R\nprint.AspiradorDePo <- function(obj) {\n  cat(\"(M1,M2,M3,M4,X,Y): (\", obj$desc, \")\\n\")\n  cat(\"G(n): \", obj$g, \"\\n\")\n  cat(\"H(n): \", obj$h, \"\\n\")\n  cat(\"F(n): \", obj$f, \"\\n\")\n}\n\n## Sobrecarga da função genérica \"heuristica\", definida por Estado.R\nheuristica.AspiradorDePo <- function(atual){\n  \n  if(is.null(atual$desc))\n    return(Inf)\n  ## h(obj) = M1 + M2 + M3 + M4\n  return(sum(atual$desc[1:4]))\n}\n\n\n#Metodo para gerar filhos de um dado estado corrente\ngeraFilhos.AspiradorDePo <- function(obj) {\n  \n  #Um estado e representado : (M1,M2,M3,M4,X,Y) => Mi = 1, posicao suja, Mi=0, limpa\n  #                                           => X,Y , posicao atual do aspirador\n  \n  filhosDesc <- list() #lista de filhos inclusive incompativeis\n  filhos <- list() # lista de filhos sem incompativeis\n  \n  desc <- obj$desc #desc recebe estado a ter filhos gerados\n  \n  #operadores\n  \n  #Caso aspirador em (1,1)\n  if(desc[5]==1 && desc[6]==1){\n      operadores <- list(c(-1,0,0,0,0,0), c(0,0,0,0,-1,0), c(0,0,0,0,1,0), c(0,0,0,0,0,-1), c(0,0,0,0,0,1))\n      #custo aplicacao dos operadores\n      custo <- c(2,1,1,3,3)\n      \n  #Caso operador em (1,2)\n  }else if(desc[5]==1 && desc[6]==2){\n    operadores <- list(c(0,-1,0,0,0,0), c(0,0,0,0,-1,0), c(0,0,0,0,1,0), c(0,0,0,0,0,-1), c(0,0,0,0,0,1))\n    #custo aplicacao dos operadores\n    custo <- c(2,1,1,3,3)\n    \n    }#Caso operado em (2,1)\n  else if(desc[5]==2 && desc[6]==1){\n    operadores <- list(c(0,0,-1,0,0,0), c(0,0,0,0,-1,0), c(0,0,0,0,1,0), c(0,0,0,0,0,-1), c(0,0,0,0,0,1))\n    #custo aplicacao dos operadores\n    custo <- c(2,1,1,3,3)\n    \n   }#Caso operador em (2,2)\n  else if(desc[5]==2 && desc[6]==2){\n    operadores <- list(c(0,0,0,-1,0,0), c(0,0,0,0,-1,0), c(0,0,0,0,1,0), c(0,0,0,0,0,-1), c(0,0,0,0,0,1))\n    #custo aplicacao dos operadores\n    custo <- c(2,1,1,3,3)\n    \n  }\n  \n  #geracao de filhos inclusive com incompativeis\n  filhosDesc <- lapply(operadores, function(op) desc+op)\n  \n  #remocao de estados incompativeis => quando alguma posicao de celula for <0 OU quando posicao X,Y for fora dos limites 2 X 2\n  incompativeis <- sapply(1:length(filhosDesc),\n                          function(i){\n                            fDesc = filhosDesc[[i]] #pega estado\n                            \n                            retorno <- 0\n                            \n                            #verifica se posicao celula negativa\n                            for(k in 1:4){\n                              if(fDesc[k]<0){\n                                retorno <- i\n                              }\n                            }\n                            \n                            #verifica limites de posicao em grid 2X2\n                            if(fDesc[5]<1 || fDesc[5]>2 || fDesc[6]<1 || fDesc[6]>2){\n                              retorno <- i\n                            }\n                            \n                            return(retorno)\n                            \n                            \n                          }) #fim sapply\n  \n    #Manter no vetor incompativeis apenas indices dos incompativeis => != 0\n    incompativeis <- incompativeis[incompativeis!=0]\n    \n    #Colocar no vetor FilhosDesc apenas filhos compativeis\n    filhosDesc <- filhosDesc[-incompativeis]\n    custo <- custo[-incompativeis]\n    \n    #Geracao de objetos AspiradorDePo para filhos\n    i <- 1 #contador\n    for(filhoDesc in filhosDesc){\n      filho <- AspiradorDePo(desc=filhoDesc,pai=obj)\n      filho$h <- heuristica(filho)\n      filho$g <- obj$g + custo[i] #pega custo gasto na geracao deste estado filho\n      i <- i + 1\n      filhos <- c(filhos, list(filho))\n    }\n    \n  \n    return(filhos)\n  \n}\n\n",
    "created" : 1482716279895.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1068347201",
    "id" : "BB9F89FF",
    "lastKnownWriteTime" : 1482775466,
    "last_content_update" : 1482775466970,
    "path" : "~/Documents/AI/T1/AspiradorDePo/AspiradorDePo.R",
    "project_path" : "AspiradorDePo.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}